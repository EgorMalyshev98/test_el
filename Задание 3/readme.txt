Часть 1: Оптимизированная загрузка в БД
1. Напишите ETL-скрипт:
- Читает CSV-файл с заказами (1 млн строк).
- Выполняет нормализацию данных (выносит курсы и предметы в справочные таблицы).
- Использует batch-загрузку (COPY вместо INSERT).
- Работает асинхронно (например, asyncpg для PostgreSQL).
Файлы с решением:
    - task_1.py
    - ddl.sql

2. Как ускорить загрузку данных?
- Какие параметры БД (work_mem, shared_buffers) можно настроить?
    Настройки WAL:
        - Можно записывать в unlogged таблицы(без записи в WAL), если потеря данных при сбое допускается
        - увеличить max_wal_size
        - увеличить checkpoint_timeout
    Настройки памяти:
        - увеличить shared_buffers, чтобы избежать работы с диском
        - увеличить work_mem: если логика загрузки сложная и требуется производить sql запросы к целевым таблицам
        - увеличить maintenance_work_mem, чтобы ускорить операции обслуживания после вставки

- Как избежать блокировок таблиц при массовой вставке?
    - если целостность загрузки не важна, то можно вставлять батчи в отдельных транзакциях
    - вставлять во временную таблицу
    - при использовании COPY FROM запросы на чтение не блокируются

Часть 2: Оптимизация SQL-запросов
1. Напишите SQL-запрос, который возвращает ТОП-5 самых продаваемых курсов по месяцам.
    файл query.sql
2. Напишите SQL-запрос, который возвращает ТОП-3 самых популярных пакетов по предметам.
    файл query.sql
3. Оптимизируйте запросы:
- Какие индексы добавить?
    - Оба запроса выбирают большое кол-во строк относительно общего кол-ва строк в таблицах,
    а значит индексы в классических СУБД(например btree в postgres) будут неэффективны,
    и планировщик предпочтет им последовательное сканирование.

- Какую стратегию партиционирования выбрать (range, hash)?
    Можно использовать range по дате (например в разбивке по месяцам), но это будет работать только 
    если в условии запроса присутствует ключ партиционирования и запросы затрагивают небольшое кол-во партиций.

- Как минимизировать full table scan?
    В основном планировщик сам определяет оптимальный план выполнения и минимизирует кол-во строк в шагах запроса.
    В случае, если запрос слишком большой и планировщик не может выбрать оптимальный план, 
    он будет выполнять запрос последовательно. В таком случае следует обеспечить следует писать запрос так, 
    чтобы на каждом шаге запроса было отброшено как можно большее кол-во строк.